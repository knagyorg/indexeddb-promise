(function (f) {
  if (typeof exports === 'object' && typeof module !== 'undefined') {
    module.exports = f();
  } else if (typeof define === 'function' && define.amd) {
    define([], f);
  } else {
    var g;
    if (typeof window !== 'undefined') {
      g = window;
    } else if (typeof global !== 'undefined') {
      g = global;
    } else if (typeof self !== 'undefined') {
      g = self;
    } else {
      g = this;
    }
    g.IndexedDB = f();
  }
})(function () {
  var define, module, exports;
  return (function () {
    function r(e, n, t) {
      function o(i, f) {
        if (!n[i]) {
          if (!e[i]) {
            var c = 'function' == typeof require && require;
            if (!f && c) return c(i, !0);
            if (u) return u(i, !0);
            var a = new Error("Cannot find module '" + i + "'");
            throw ((a.code = 'MODULE_NOT_FOUND'), a);
          }
          var p = (n[i] = { exports: {} });
          e[i][0].call(
            p.exports,
            function (r) {
              var n = e[i][1][r];
              return o(n || r);
            },
            p,
            p.exports,
            r,
            e,
            n,
            t,
          );
        }
        return n[i].exports;
      }
      for (var u = 'function' == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
      return o;
    }
    return r;
  })()(
    {
      1: [
        function (require, module, exports) {
          'use strict';

          /**
           * @typedef {string | number | boolean | null | undefined} Item
           */

          /**
           * @typedef {{[key: string]: Item} | Item} ListItem
           */

          /**
           * @description Array sorter
           * @param {ListItem[]} listToBeSorted
           */
          var arraySorter = function arraySorter(listToBeSorted) {
            if (!Array.isArray(listToBeSorted)) {
              throw new Error('The list to be sorted must be an array');
            }
            /**
             * @description Sorts array by key property
             * @param {{
             *   keys: string | string[],
             *   desc?: boolean,
             * } | string | {}} props
             * @returns {*[]}
             */

            this.sortBy = function () {
              var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              /** @type {{sorted: ListItem[], keys: [string]}} */
              var ref = {
                sorted: listToBeSorted,
                keys: null,
              };
              if (props.hasOwnProperty('keys')) ref.keys = props.keys;
              if (typeof props === 'string') ref.keys = [props];

              if (Array.isArray(ref.keys)) {
                ref.keys.forEach(
                  /** @param {string} key */
                  function (key) {
                    ref.sorted = ref.sorted.sort(
                      /**
                       * @param {ListItem} next
                       * @param {ListItem} current
                       * @returns {number}
                       */
                      function (next, current) {
                        var _current$key, _next$key, _current$key2, _next$key2;

                        // Sorting by number key
                        if (!isNaN(current[key]) && !isNaN(next[key])) {
                          return next[key] - current[key];
                        } // Sorting by date key

                        if (!isNaN(new Date(current[key]).valueOf())) {
                          var $current = new Date(current[key]).valueOf();
                          var $next = {
                            val: new Date(0).valueOf(),
                          };

                          if (!isNaN(new Date(next[key]).valueOf())) {
                            $next.val = new Date(next[key]).valueOf();
                          }

                          if ($current > $next.val) return -1;
                          if ($current < $next.val) return 1;
                          return 0;
                        } // Alphabetical sorting

                        if (
                          ((_current$key = current[key]) === null || _current$key === void 0
                            ? void 0
                            : _current$key.toLowerCase()) >
                          ((_next$key = next[key]) === null || _next$key === void 0 ? void 0 : _next$key.toLowerCase())
                        )
                          return -1;
                        if (
                          ((_current$key2 = current[key]) === null || _current$key2 === void 0
                            ? void 0
                            : _current$key2.toLowerCase()) <
                          ((_next$key2 = next[key]) === null || _next$key2 === void 0
                            ? void 0
                            : _next$key2.toLowerCase())
                        )
                          return 1;
                        return 0;
                      },
                    );
                  },
                );
              } else {
                ref.sorted = ref.sorted.sort(
                  /**
                   * @param {ListItem} next
                   * @param {ListItem} current
                   * @returns {number}
                   */
                  function (next, current) {
                    // Sorting by number key
                    if (!isNaN(current) && !isNaN(next)) {
                      return next - current;
                    } // Alphabetical sorting

                    if (
                      (current === null || current === void 0 ? void 0 : current.toLowerCase()) >
                      (next === null || next === void 0 ? void 0 : next.toLowerCase())
                    )
                      return -1;
                    if (
                      (current === null || current === void 0 ? void 0 : current.toLowerCase()) <
                      (next === null || next === void 0 ? void 0 : next.toLowerCase())
                    )
                      return 1;
                    return 0;
                  },
                );
              }

              if (props.hasOwnProperty('desc') && props.desc) {
                ref.sorted = ref.sorted.reverse();
              }

              return ref.sorted;
            };
          };
          /**
           * @description Singleton pattern for Array sorter
           * @param {ListItem[]} list
           * @returns {arraySorter}
           */

          module.exports = function (list) {
            return new arraySorter(list);
          };
        },
        {},
      ],
      2: [
        function (require, module, exports) {
          'use strict';

          function _createForOfIteratorHelper(o, allowArrayLike) {
            var it = (typeof Symbol !== 'undefined' && o[Symbol.iterator]) || o['@@iterator'];
            if (!it) {
              if (
                Array.isArray(o) ||
                (it = _unsupportedIterableToArray(o)) ||
                (allowArrayLike && o && typeof o.length === 'number')
              ) {
                if (it) o = it;
                var i = 0;
                var F = function F() {};
                return {
                  s: F,
                  n: function n() {
                    if (i >= o.length) return { done: true };
                    return { done: false, value: o[i++] };
                  },
                  e: function e(_e) {
                    throw _e;
                  },
                  f: F,
                };
              }
              throw new TypeError(
                'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
              );
            }
            var normalCompletion = true,
              didErr = false,
              err;
            return {
              s: function s() {
                it = it.call(o);
              },
              n: function n() {
                var step = it.next();
                normalCompletion = step.done;
                return step;
              },
              e: function e(_e2) {
                didErr = true;
                err = _e2;
              },
              f: function f() {
                try {
                  if (!normalCompletion && it['return'] != null) it['return']();
                } finally {
                  if (didErr) throw err;
                }
              },
            };
          }

          function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === 'string') return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === 'Object' && o.constructor) n = o.constructor.name;
            if (n === 'Map' || n === 'Set') return Array.from(o);
            if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
              return _arrayLikeToArray(o, minLen);
          }

          function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;
            for (var i = 0, arr2 = new Array(len); i < len; i++) {
              arr2[i] = arr[i];
            }
            return arr2;
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ('value' in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
          }

          var arraySorter = require('./array-sorter');
          /**
           * @typedef {{
           *   version: number,
           *   databaseName: string,
           *   tableName: string,
           *   primaryKey: {
           *     name: string,
           *     autoIncrement: boolean,
           *   },
           *   initData?: Array<{
           *     [key: string]: any,
           *   }>,
           *   structure: Array<{
           *      [key: string]: {
           *        unique?: boolean,
           *        multiEntry?: boolean,
           *      },
           *   }>
           * }} Config
           */

          var Model = /*#__PURE__*/ (function () {
            function Model() {
              var _this = this;

              _classCallCheck(this, Model);

              this.tableName = this.config.tableName || 'table';
              this.fingersCrossed = new Promise(function (resolve, reject) {
                if (!window || !('indexedDB' in window)) {
                  return reject('Unsupported environment');
                }

                if (Array.isArray(_this.config)) {
                  return reject('Config has to be an Object');
                }

                var version = _this.config.version || 1;
                var request = window.indexedDB.open(_this.config.databaseName || 'db', version);

                request.onerror = function (event) {
                  return reject('Unexpected exception: ', event.target || event);
                };

                request.onsuccess = function () {
                  var connection = request.result;

                  connection.onversionchange = function () {
                    connection.close();
                    console.info('connection closed...');
                  };

                  return resolve(request.result);
                };

                request.onblocked = function (event) {
                  event.target.result.close();
                  console.warn('blocked');
                };

                request.onupgradeneeded = function (event) {
                  var _this$config$primaryK, _this$config$primaryK2;

                  var db = event.target.result;

                  if (
                    (event.oldVersion < version && event.oldVersion !== 0) ||
                    db.objectStoreNames.contains(_this.config.tableName)
                  ) {
                    db.deleteObjectStore(_this.config.tableName);
                    console.info('Table: ', _this.config.tableName, ' removed');
                  }

                  var store = db.createObjectStore(_this.config.tableName, {
                    keyPath:
                      ((_this$config$primaryK = _this.config.primaryKey) === null || _this$config$primaryK === void 0
                        ? void 0
                        : _this$config$primaryK.name) || 'id',
                    autoIncrement:
                      ((_this$config$primaryK2 = _this.config.primaryKey) === null || _this$config$primaryK2 === void 0
                        ? void 0
                        : _this$config$primaryK2.autoIncrement) || true,
                  });

                  for (var key in _this.config.structure) {
                    if (_this.config.structure.hasOwnProperty(key)) {
                      store.createIndex('Index-'.concat(key), key, {
                        unique: !!_this.config.structure[key].unique,
                        multiEntry: !!_this.config.structure[key].multiEntry,
                      });
                    }
                  }

                  var _iterator = _createForOfIteratorHelper(_this.config.initData || []),
                    _step;

                  try {
                    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                      var data = _step.value;
                      store.add(data);
                    }
                  } catch (err) {
                    _iterator.e(err);
                  } finally {
                    _iterator.f();
                  }
                };
              });
            }
            /**
             * @constructor
             * @returns {Config}
             */

            _createClass(Model, [
              {
                key: 'config',
                get: function get() {
                  return {
                    version: 1,
                    databaseName: 'DefaultDatabase',
                    tableName: 'DefaultTable',
                    primaryKey: {
                      name: 'id',
                      autoIncrement: true,
                    },
                    initData: [],
                    structure: {
                      roomId: {
                        unique: false,
                        multiEntry: true,
                      },
                      roomName: {
                        unique: false,
                        multiEntry: false,
                      },
                      task: {
                        unique: false,
                        multiEntry: false,
                      },
                    },
                  };
                },
                /**
                 * @description This method is used to get the structure of the table, verify and return it.
                 * @param {{[key:string]: any}} data
                 * @returns {{[key:string]: any}}
                 */
              },
              {
                key: 'verify',
                value: function verify(data) {
                  var _this$config$primaryK4;

                  var keys = Object.keys(data);

                  for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
                    var _this$config$structur, _this$config$primaryK3;

                    var key = _keys[_i];

                    if (
                      !(
                        (_this$config$structur = this.config.structure) !== null &&
                        _this$config$structur !== void 0 &&
                        _this$config$structur[key]
                      ) &&
                      ((_this$config$primaryK3 = this.config.primaryKey) === null || _this$config$primaryK3 === void 0
                        ? void 0
                        : _this$config$primaryK3.name) !== key
                    ) {
                      throw new Error(
                        '{'.concat(key, '} is not a valid key. Not defined in configuration [structure].'),
                      );
                    }
                  }

                  if (
                    ((_this$config$primaryK4 = this.config.primaryKey) === null || _this$config$primaryK4 === void 0
                      ? void 0
                      : _this$config$primaryK4.autoIncrement) === false
                  ) {
                    var _this$config$primaryK5;

                    if (
                      !keys.includes(
                        (_this$config$primaryK5 = this.config.primaryKey) === null || _this$config$primaryK5 === void 0
                          ? void 0
                          : _this$config$primaryK5.name,
                      )
                    ) {
                      throw new Error('Either include primary key as well or set {autoincrement: true}.');
                    }
                  }

                  return data;
                },
                /**
                 * @description This method is used to insert data into the table.
                 * @param {{[key: string]: any}} data
                 * @returns {Promise<any>}
                 */
              },
              {
                key: 'insertData',
                value: function insertData(data) {
                  var _this2 = this;

                  var verifiedInsertData = this.verify(data);
                  return new Promise(function (resolve, reject) {
                    _this2.fingersCrossed.then(function (db) {
                      var request = db
                        .transaction([_this2.tableName], 'readwrite')
                        .objectStore(_this2.tableName)
                        .add(verifiedInsertData);

                      request.onsuccess = function () {
                        return resolve(db);
                      };

                      request.onerror = function () {
                        reject('Unable to add data. Check the unique values');
                      };
                    });
                  });
                },
                /**
                 * @description This method is used to select data from the table.
                 * @param {string} pKey
                 * @returns {Promise<any>}
                 */
              },
              {
                key: 'selectFrom',
                value: function selectFrom(pKey) {
                  var _this3 = this;

                  return new Promise(function (resolve, reject) {
                    _this3.fingersCrossed.then(function (db) {
                      var transaction = db.transaction([_this3.tableName]);
                      var objectStore = transaction.objectStore(_this3.tableName);
                      var request = objectStore.get(pKey);

                      request.onerror = function () {
                        return reject('Unable to retrieve data from the model');
                      };

                      request.onsuccess = function () {
                        if (request.result) {
                          return resolve(request.result);
                        } else {
                          return reject('No result found');
                        }
                      };
                    });
                  });
                },
              },
              {
                key: 'selectAll',
                value: function selectAll() {
                  var _this4 = this;

                  return new Promise(function (resolve, reject) {
                    _this4.fingersCrossed.then(function (db) {
                      var objectStore = db.transaction(_this4.tableName).objectStore(_this4.tableName);
                      var request = objectStore.getAll();

                      request.onsuccess = function () {
                        if (request.result) {
                          return resolve(request.result);
                        } else {
                          return reject('No result found');
                        }
                      };

                      request.onerror = function () {
                        return reject("Can't get data from database");
                      };
                    });
                  });
                },
                /**
                 * @description This method is used to select data from the table.
                 * @param {{
                 *   where: function({}),
                 *   limit?: number,
                 *   orderByDESC?: boolean,
                 *   sortBy?: string | string[]
                 * }} options
                 * @returns {Promise<any>}
                 */
              },
              {
                key: 'selectWhere',
                value: function selectWhere(options) {
                  var _this5 = this;

                  var props = new Proxy(options, {
                    get: function get(target, name) {
                      return name in target ? target[name] : false;
                    },
                  });
                  return new Promise(function (resolve, reject) {
                    _this5.selectAll().then(resolve)['catch'](reject);
                  }).then(function (dataBucket) {
                    var result = {
                      val: [],
                    };

                    if ('where' in props && props.where !== false) {
                      if (dataBucket.length === 0) return [];

                      if (typeof props.where === 'function') {
                        // exec callback fn and return
                        result.val = props.where.call(dataBucket, dataBucket);
                      }
                    }

                    if ('sortBy' in props && props.sortBy) {
                      // sort data
                      result.val = arraySorter(result.val).sortBy({
                        desc: 'orderByDESC' in props && props.orderByDESC,
                        keys: [props.sortBy],
                      });
                    }

                    if ('limit' in props && props.limit !== false) {
                      // slice data
                      result.val = result.val.slice(0, +props.limit);
                    }

                    return result.val;
                  });
                },
                /**
                 * @description This method is used to update data in the table.
                 * @param {string} pKey
                 * @param {{[key: string]: any}} dataToUpdate
                 * @returns {Promise<any>}
                 */
              },
              {
                key: 'updateWhere',
                value: function updateWhere(pKey, dataToUpdate) {
                  var _this6 = this;

                  return new Promise(function (resolve, reject) {
                    _this6.fingersCrossed.then(function (db) {
                      _this6.selectFrom(pKey).then(function (fetchedData) {
                        var transaction = db.transaction([_this6.tableName], 'readwrite');
                        var store = transaction.objectStore(_this6.tableName);
                        var data = Object.assign(fetchedData, dataToUpdate);
                        var save = store.put(data);

                        save.onsuccess = function () {
                          return resolve(data);
                        };

                        save.onerror = function () {
                          return reject('Cannot update data');
                        };
                      });
                    });
                  });
                },
                /**
                 * @description This method is used to delete data from the table.
                 * @param {string} pKey
                 * @returns {Promise<unknown>}
                 */
              },
              {
                key: 'deleteWhere',
                value: function deleteWhere(pKey) {
                  var _this7 = this;

                  return new Promise(function (resolve, reject) {
                    _this7.fingersCrossed.then(function (db) {
                      var request = db
                        .transaction([_this7.tableName], 'readwrite')
                        .objectStore(_this7.tableName)
                        ['delete'](pKey);

                      request.onsuccess = function () {
                        return resolve(pKey);
                      };

                      request.onerror = function () {
                        return reject("Couldn't remove an item");
                      };
                    });
                  });
                },
              },
            ]);

            return Model;
          })();

          module.exports = {
            Model: Model,
          };
        },
        { './array-sorter': 1 },
      ],
    },
    {},
    [2],
  )(2);
});
