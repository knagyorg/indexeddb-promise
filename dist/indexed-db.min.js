(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.IndexedDB = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

/**
 * @typedef {string | number | boolean | null | undefined} Item
 */

/**
 * @typedef {{[key: string]: Item} | Item} ListItem
 */

/**
 * @description Array sorter
 * @param {ListItem[]} listToBeSorted
 */
var arraySorter = function arraySorter(listToBeSorted) {
  if (!Array.isArray(listToBeSorted)) {
    throw new Error('The list to be sorted must be an array');
  }
  /**
   * @description Sorts array by key property
   * @param {{
   *   keys: string | string[],
   *   desc?: boolean,
   * } | string | {}} props
   * @returns {*[]}
   */


  this.sortBy = function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    /** @type {{sorted: ListItem[], keys: [string]}} */
    var ref = {
      sorted: listToBeSorted,
      keys: null
    };
    if (props.hasOwnProperty('keys')) ref.keys = props.keys;
    if (typeof props === 'string') ref.keys = [props];

    if (Array.isArray(ref.keys)) {
      ref.keys.forEach(
      /** @param {string} key */
      function (key) {
        ref.sorted = ref.sorted.sort(
        /**
         * @param {ListItem} next
         * @param {ListItem} current
         * @returns {number}
         */
        function (next, current) {
          var _current$key, _next$key, _current$key2, _next$key2;

          // Sorting by number key
          if (!isNaN(current[key]) && !isNaN(next[key])) {
            return next[key] - current[key];
          } // Sorting by date key


          if (!isNaN(new Date(current[key]).valueOf())) {
            var $current = new Date(current[key]).valueOf();
            var $next = {
              val: new Date(0).valueOf()
            };

            if (!isNaN(new Date(next[key]).valueOf())) {
              $next.val = new Date(next[key]).valueOf();
            }

            if ($current > $next.val) return -1;
            if ($current < $next.val) return 1;
            return 0;
          } // Alphabetical sorting


          if (((_current$key = current[key]) === null || _current$key === void 0 ? void 0 : _current$key.toLowerCase()) > ((_next$key = next[key]) === null || _next$key === void 0 ? void 0 : _next$key.toLowerCase())) return -1;
          if (((_current$key2 = current[key]) === null || _current$key2 === void 0 ? void 0 : _current$key2.toLowerCase()) < ((_next$key2 = next[key]) === null || _next$key2 === void 0 ? void 0 : _next$key2.toLowerCase())) return 1;
          return 0;
        });
      });
    } else {
      ref.sorted = ref.sorted.sort(
      /**
       * @param {ListItem} next
       * @param {ListItem} current
       * @returns {number}
       */
      function (next, current) {
        // Sorting by number key
        if (!isNaN(current) && !isNaN(next)) {
          return next - current;
        } // Alphabetical sorting


        if ((current === null || current === void 0 ? void 0 : current.toLowerCase()) > (next === null || next === void 0 ? void 0 : next.toLowerCase())) return -1;
        if ((current === null || current === void 0 ? void 0 : current.toLowerCase()) < (next === null || next === void 0 ? void 0 : next.toLowerCase())) return 1;
        return 0;
      });
    }

    if (props.hasOwnProperty('desc') && props.desc) {
      ref.sorted = ref.sorted.reverse();
    }

    return ref.sorted;
  };
};
/**
 * @description Singleton pattern for Array sorter
 * @param {ListItem[]} list
 * @returns {arraySorter}
 */


module.exports = function (list) {
  return new arraySorter(list);
};

},{}],2:[function(require,module,exports){
"use strict";

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var arraySorter = require('./array-sorter');
/**
 * @typedef {{
 *   version: number,
 *   databaseName: string,
 *   tableName: string,
 *   primaryKey: {
 *     name: string,
 *     autoIncrement: boolean,
 *     unique: boolean,
 *   },
 *   initData?: Array<{
 *     [key: string]: any,
 *   }>,
 *   indexes: {
 *      [key: string]: {
 *        unique?: boolean,
 *        multiEntry?: boolean,
 *      },
 *   }
 * }} Config
 */


var Model = /*#__PURE__*/function () {
  /**
   * @param {Config} config
   */
  function Model(config) {
    var _this = this;

    _classCallCheck(this, Model);

    this.config = config || {
      version: 1,
      databaseName: 'DefaultDatabase',
      tableName: 'DefaultTable',
      primaryKey: {
        name: 'id',
        autoIncrement: true
      },
      initData: [],
      indexes: {
        id: {
          unique: false,
          multiEntry: true
        },
        username: {
          unique: false,
          multiEntry: false
        }
      }
    };
    this.tableName = this.config.tableName || 'table';

    if (Array.isArray(this.config)) {
      throw new Error('Config has to be an Object');
    }

    this.fingersCrossed = new Promise(function (resolve, reject) {
      if (!window || !('indexedDB' in window) || !('open' in window.indexedDB)) {
        return reject('Unsupported environment');
      }

      var version = _this.config.version || 1;
      var request = window.indexedDB.open(_this.config.databaseName || 'db', version);

      request.onerror = function (event) {
        return reject(request.error || "Make sure you aren't inserting duplicated data for indexed unique values");
      };

      request.onsuccess = function () {
        var connection = request.result;

        connection.onversionchange = function () {
          connection.close();
          console.info('connection closed...');
        };

        return resolve(request.result);
      };

      request.onblocked = function (event) {
        event.target.result.close();
        console.warn('blocked');
      };

      request.onupgradeneeded = function (event) {
        var _this$config$primaryK, _this$config$primaryK2;

        var db = event.target.result;

        if (event.oldVersion < version && event.oldVersion !== 0 || db.objectStoreNames.contains(_this.config.tableName)) {
          db.deleteObjectStore(_this.config.tableName);
          console.info("DB version changed, therefore table: ".concat(_this.config.tableName, " has removed"));
        }

        var store = db.createObjectStore(_this.config.tableName, {
          keyPath: ((_this$config$primaryK = _this.config.primaryKey) === null || _this$config$primaryK === void 0 ? void 0 : _this$config$primaryK.name) || 'id',
          autoIncrement: ((_this$config$primaryK2 = _this.config.primaryKey) === null || _this$config$primaryK2 === void 0 ? void 0 : _this$config$primaryK2.autoIncrement) || true
        });

        for (var key in _this.config.indexes) {
          if (Reflect.has(_this.config.indexes, key)) {
            store.createIndex(key, key, {
              unique: !!_this.config.indexes[key].unique,
              multiEntry: !!_this.config.indexes[key].multiEntry
            });
          }
        }

        var _iterator = _createForOfIteratorHelper(_this.config.initData || []),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var data = _step.value;
            store.add(data);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      };
    });
  }
  /**
   * @description This method is used to get the indexes of the table, verify and return it.
   * @param {{[key:string]: any}} data
   * @returns {{[key:string]: any}}
   */


  _createClass(Model, [{
    key: "verify",
    value: function verify(data) {
      var _this$config$primaryK3;

      var keys = Object.keys(data);

      if (((_this$config$primaryK3 = this.config.primaryKey) === null || _this$config$primaryK3 === void 0 ? void 0 : _this$config$primaryK3.autoIncrement) === false) {
        var _this$config$primaryK4;

        if (!keys.includes((_this$config$primaryK4 = this.config.primaryKey) === null || _this$config$primaryK4 === void 0 ? void 0 : _this$config$primaryK4.name)) {
          throw new Error('Either include primary key as well or set {autoincrement: true}.');
        }
      }

      return data;
    }
    /**
     * @description This method is used to insert data into the table.
     * @param {{[key: string]: any}} data
     * @returns {Promise<any>}
     */

  }, {
    key: "insert",
    value: function insert(data) {
      var _this2 = this;

      var verifiedInsertData = this.verify(data);
      return new Promise(function (resolve, reject) {
        _this2.fingersCrossed.then(function (db) {
          var request = db.transaction([_this2.tableName], 'readwrite').objectStore(_this2.tableName).add(verifiedInsertData);

          request.onsuccess = function () {
            return resolve(data, db);
          };

          request.onerror = function () {
            return reject(request.error || 'Unable to add data. Check the unique values');
          };
        });
      });
    }
    /**
     * @description This method is used to select data from the table by Primary key.
     * @param {string} pKey
     * @returns {Promise<ListItem|null|undefined>}
     */

  }, {
    key: "selectByPk",
    value: function selectByPk(pKey) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        _this3.fingersCrossed.then(function (db) {
          var transaction = db.transaction([_this3.tableName]);
          var objectStore = transaction.objectStore(_this3.tableName);
          var request = objectStore.get(pKey);

          request.onerror = function () {
            return reject(request.error || 'Unable to retrieve data from the model');
          };

          request.onsuccess = function () {
            return resolve(request.result);
          };
        });
      });
    }
    /**
     * @description This method is used to select data from the table by defined Index key.
     * @param {string} indexName
     * @param {string} value
     * @returns {Promise<ListItem|null|undefined>}
     */

  }, {
    key: "selectByIndex",
    value: function selectByIndex(indexName, value) {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        _this4.fingersCrossed.then(function (db) {
          var transaction = db.transaction([_this4.tableName]);
          var objectStore = transaction.objectStore(_this4.tableName);
          var request = objectStore.index(indexName).get(value);

          request.onerror = function () {
            return reject(request.error || "Unable to retrieve data from the model by ".concat(indexName));
          };

          request.onsuccess = function () {
            return resolve(request.result);
          };
        });
      });
    }
    /**
     * @description This method is used to select all the data from the table.
     * @returns {Promise<ListItem[]>}
     */

  }, {
    key: "selectAll",
    value: function selectAll() {
      var _this5 = this;

      return new Promise(function (resolve, reject) {
        _this5.fingersCrossed.then(function (db) {
          var objectStore = db.transaction(_this5.tableName).objectStore(_this5.tableName);
          var request = objectStore.getAll();

          request.onsuccess = function () {
            return resolve(request.result);
          };

          request.onerror = function () {
            return reject(request.error || "Can't get data from database");
          };
        });
      });
    }
    /**
     * @description This method is used to select data from the table.
     * @param  {{
     *   where?: {
     *     [key: string]: any
     *   } | function(ListItem[]):ListItem[],
     *   limit?: number,
     *   orderByDESC?: boolean,
     *   sortBy?: string | string[]
     * }} options
     * @returns {Promise<ListItem[]>}
     */

  }, {
    key: "select",
    value: function select(options) {
      var _this6 = this;

      var props = new Proxy(options, {
        get: function get(target, name) {
          return name in target ? target[name] : false;
        }
      });
      return new Promise(function (resolve, reject) {
        _this6.selectAll().then(resolve).catch(reject);
      }).then(function (dataBucket) {
        var result = {
          val: []
        };

        if ('where' in props && props.where !== false) {
          if (dataBucket.length === 0) return [];

          if (typeof props.where === 'function') {
            result.val = props.where.call(dataBucket, dataBucket);
          } else {
            var whereKeys = Object.keys(props.where);
            result.val = dataBucket.filter(function (item) {
              var dataKeys = Object.keys(item);

              var _iterator2 = _createForOfIteratorHelper(whereKeys),
                  _step2;

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var key = _step2.value;

                  if (dataKeys.includes(key) && item[key] === props.where[key]) {
                    return true;
                  }
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }

              return false;
            });
          }
        }

        if ('sortBy' in props && props.sortBy) {
          // sort data
          result.val = arraySorter(result.val).sortBy({
            desc: 'orderByDESC' in props && props.orderByDESC,
            keys: [props.sortBy]
          });
        }

        if ('limit' in props && props.limit !== false) {
          // slice data
          result.val = result.val.slice(0, +props.limit);
        }

        return result.val;
      });
    }
    /**
     * @description This method is used to update data in the table.
     * @param {string} pKey
     * @param {{[key: string]: any}} dataToUpdate
     * @returns {Promise<any>}
     */

  }, {
    key: "updateByPk",
    value: function updateByPk(pKey, dataToUpdate) {
      var _this7 = this;

      return new Promise(function (resolve, reject) {
        _this7.fingersCrossed.then(function (db) {
          _this7.selectByPk(pKey).then(function (fetchedData) {
            var transaction = db.transaction([_this7.tableName], 'readwrite');
            var store = transaction.objectStore(_this7.tableName);
            var data = Object.assign(fetchedData, dataToUpdate);
            var save = store.put(data);

            save.onsuccess = function () {
              return resolve(data);
            };

            save.onerror = function () {
              return reject(save.error || 'Cannot update data');
            };
          });
        });
      });
    }
    /**
     * @description This method is used to delete data from the table.
     * @param {string} pKey
     * @returns {Promise<unknown>}
     */

  }, {
    key: "deleteByPk",
    value: function deleteByPk(pKey) {
      var _this8 = this;

      return new Promise(function (resolve, reject) {
        _this8.fingersCrossed.then(function (db) {
          var transaction = db.transaction([_this8.tableName], 'readwrite');
          var request = transaction.objectStore(_this8.tableName).delete(pKey);

          request.onsuccess = function () {
            return resolve(pKey);
          };

          request.onerror = function () {
            return reject(request.error || "Couldn't remove an item");
          };
        });
      });
    }
  }]);

  return Model;
}();

module.exports = {
  Model: Model
};

},{"./array-sorter":1}]},{},[2])(2)
});
